import NodePatcher, { NodePatcherRule, NodePatcherRuleTypes } from "./NodePatcher";

interface NodeInstancePatchingData {
    /**
     * The patching data shared among the nodes generated by the same template 
     */
    sharedPatchingData: NodeSharedPatchingData;

    /**
     * The values previously used to generate the node from the template
     */
    values: any[];
}

interface NodeInstancePatchingDataHolder {

    __instancePatchingData__: NodeInstancePatchingData;
}

const attributeMarkerPrefix = "_$attr:";

const commentMarker = "_$child_";

/**
 * The shared patching data of the nodes generated by the same template
 */
export default class NodeSharedPatchingData {

    /**
     * The patcher to patch the node
     */
    private _patcher: NodePatcher;

    /**
     * The template to clone and generate the node from
     */
    private _template: HTMLTemplateElement;

    constructor(strings: TemplateStringsArray) {

        this._template = createTemplate(strings);

        const rules: NodePatcherRule[] = createNodePatcherRules(this._template.content);

        this._patcher = new NodePatcher(rules);
    }

    createNode(oldValues: any[], newValues: any[]): Node {

        // The content of the template is a document fragment
        let node = this._template.content.cloneNode(/*deep*/true);

        this._patcher.patch(node, oldValues, newValues);

        (node as unknown as NodeInstancePatchingDataHolder).__instancePatchingData__ = {
            sharedPatchingData: this,
            values: newValues // Store the old values to compare
        };

        return node;
    }

    patchNode(node: Node, oldValues, newValues): void {

        this._patcher.patch(node, oldValues, newValues);
    }
}

function createTemplate(strings: TemplateStringsArray): HTMLTemplateElement {

    const parts: string[] = [];

    const length = strings.length - 1; // Exclude the last one

    for (let i = 0; i < length; ++i) {

        const s = strings[i];

        if (s.endsWith('=')) { // It is an attribute

            parts.push(`${s}"${attributeMarkerPrefix}${getAttributeName(s)}"`);
        }
        else {

            parts.push(`${s}<!--${commentMarker}-->`);
        }
    }

    parts.push(strings[length]); // Add the ending string

    const t = document.createElement('template');

    t.innerHTML = parts.join('');

    return t;
}

function getAttributeName(s: string): string {

    let b: string[] = [];

    for (let i = s.lastIndexOf('=') - 1; i >= 0; --i) {

        if (s[i] === ' ') { // Finished with the name of the attribute

            break;
        }

        b = [s[i], ...b]; // Prepend
    }

    return b.join('');
}

function createNodePatcherRules(node: Node, path: number[] = [], rules: NodePatcherRule[] = []): NodePatcherRule[] {

    const {
        childNodes
    } = node;

    const {
        length
    } = childNodes;

    if (node.nodeType === Node.COMMENT_NODE &&
        (node as Text).data === commentMarker) {

        rules.push({
            type: NodePatcherRuleTypes.PATCH_TEXT,
            path: [...path]
        });

        return rules; // Comments do not have attributes and children so we are done
    }
    else {

        const attributes = (node as HTMLElement).attributes;

        if (attributes !== undefined) {

            rules = createAttributePatcherRules(attributes, path, rules);
        }
    }

    for (let i = 0; i < length; ++i) {

        rules = createNodePatcherRules(childNodes[i], [...path, i], rules);
    }

    return rules;
}

function createAttributePatcherRules(attributes: NamedNodeMap, path: number[], rules: NodePatcherRule[]): NodePatcherRule[] {

    const {
        length
    } = attributes;

    for (let i = 0; i < length; ++i) {

        const value = attributes[i].value;

        if (value.startsWith(attributeMarkerPrefix)) {

            const name = value.split(':')[1];

            rules.push({
                type: NodePatcherRuleTypes.PATCH_ATTRIBUTE,
                path,
                name
            });
        }
    }

    return rules;
}

