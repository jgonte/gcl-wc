// import NodePatcher, { nodeMarker, NodePatcherRule, NodePatcherRuleTypes } from "./NodePatcher";

// interface NodeInstancePatchingData {
//     /**
//      * The patching data shared among the nodes generated by the same template 
//      */
//     sharedPatchingData: NodeSharedPatchingData;

//     /**
//      * The values previously used to generate the node from the template
//      */
//     values: any[];

//     /**
//      * The cloned patching rules with the references to the nodes to act upon
//      */
//     rules;
// }

// interface NodeInstancePatchingDataHolder {

//     __instancePatchingData__: NodeInstancePatchingData;
// }

// export const attributeMarkerPrefix = "_$attr:";

// export const eventMarkerPrefix = "_$evt:";

// /**
//  * The shared patching data of the nodes generated by the same template
//  */
// export default class NodeSharedPatchingData {

//     /**
//      * The patcher to patch the node
//      */
//     private _patcher: NodePatcher;

//     /**
//      * The template to clone and generate the node from
//      */
//     private _template: HTMLTemplateElement;

//     constructor(strings: TemplateStringsArray) {

//         this._template = createTemplate(strings);

//         const rules: NodePatcherRule[] = createNodePatcherRules(this._template.content);

//         this._patcher = new NodePatcher(rules);
//     }

//     createNode(oldValues: any[], newValues: any[]): Node {

//         // The content of the template is a document fragment
//         let node = this._template.content.cloneNode(/*deep*/true);

//         const rules = cloneRules(node, this._patcher.rules);

//         const newValuesHolder = {
//             newValues
//         }

//         this._patcher.patch(node, oldValues, newValuesHolder);

//         (node as unknown as NodeInstancePatchingDataHolder).__instancePatchingData__ = {
//             sharedPatchingData: this,
//             values: newValuesHolder.newValues, // Store the old values to compare
//             rules
//         };

//         return node;
//     }

//     // patchNode(node: Node, oldValues, newValues): void {

//     //     this._patcher.patch(node, oldValues, newValues);
//     // }
// }

// function createTemplate(strings: TemplateStringsArray): HTMLTemplateElement {

//     const t = document.createElement('template');

//     t.innerHTML = createTemplateString(strings);

//     return t;
// }

// export function createTemplateString(strings: TemplateStringsArray): string {

//     const parts: string[] = [];

//     const length = strings.length - 1; // Exclude the last one

//     for (let i = 0; i < length; ++i) {

//         const s = strings[i];

//         if (s.endsWith('=')) { // It is an attribute

//             const name = getAttributeName(s);

//             if (name[0] === 'o' && name[1] === 'n') { // It is an event handler

//                 parts.push(`${s}"${eventMarkerPrefix}${name}"`);
//             }
//             else {

//                 parts.push(`${s}"${attributeMarkerPrefix}${name}"`);
//             }
//         }
//         else if (!noSelfClosingTagAfter(strings, i)) {

//             parts.push(`${s}<!--${nodeMarker}-->`);
//         }
//     }

//     parts.push(strings[length]); // Add the ending string

//     return parts.join('');
// }

// function getAttributeName(s: string): string {

//     let b: string[] = [];

//     for (let i = s.lastIndexOf('=') - 1; i >= 0; --i) {

//         if (s[i] === ' ') { // Finished with the name of the attribute

//             break;
//         }

//         b = [s[i], ...b]; // Prepend
//     }

//     return b.join('');
// }

// function createNodePatcherRules(node: Node, path: number[] = [], rules: NodePatcherRule[] = []): NodePatcherRule[] {

//     const {
//         childNodes
//     } = node;

//     const {
//         length
//     } = childNodes;

//     if (node.nodeType === Node.COMMENT_NODE &&
//         (node as Text).data === nodeMarker) {

//         rules.push({
//             type: NodePatcherRuleTypes.PATCH_NODE,
//             path: [...path]
//         });

//         return rules; // Comments do not have attributes and children so we are done
//     }
//     else if (node.nodeType === Node.TEXT_NODE) {

//         return rules; // No need to create rules for a text literal
//     }
//     else {

//         const attributes = (node as HTMLElement).attributes;

//         if (attributes !== undefined) {

//             rules = createAttributePatcherRules(attributes, path, rules);
//         }
//     }

//     for (let i = 0; i < length; ++i) {

//         rules = createNodePatcherRules(childNodes[i], [...path, i], rules);
//     }

//     return rules;
// }

// function createAttributePatcherRules(attributes: NamedNodeMap, path: number[], rules: NodePatcherRule[]): NodePatcherRule[] {

//     const {
//         length
//     } = attributes;

//     for (let i = 0; i < length; ++i) {

//         const value = attributes[i].value;

//         if (value.startsWith(attributeMarkerPrefix)) {

//             const name = value.split(':')[1];

//             rules.push({
//                 type: NodePatcherRuleTypes.PATCH_ATTRIBUTE,
//                 path,
//                 name
//             });
//         }
//         else if (value.startsWith(eventMarkerPrefix)) {

//             const name = value.split(':')[1];

//             rules.push({
//                 type: NodePatcherRuleTypes.PATCH_EVENT,
//                 path,
//                 name
//             });
//         }
//     }

//     return rules;
// }

// const regexSelfClosingTag  = /\/>/;

// function noSelfClosingTagAfter(strings: TemplateStringsArray, i: number) : boolean {
   
//     for (; i < strings.length; ++i) {

//         if (regexSelfClosingTag.test(strings[i])) {

//             return true;
//         }
//     }

//     return false;
// }

// function cloneRules(content: Node, rules: NodePatcherRule[]) : NodePatcherRule[] {

//     const clonedRules: NodePatcherRule[] = [];

//     const length = rules.length;

//     for (let i = 0; i < length; i++) {

//         const clonedRule = { ...rules[i] };

//         clonedRule.node = findNode(content, clonedRule.path);
        
//         clonedRules.push(clonedRule);
//     }

//     return clonedRules;
// }

// function findNode(node: Node, path: number[]): Node {

//     let p = path;

//     for (let i = 0; i < p.length; ++i) {

//         const index = p[i];

//         node = node.childNodes[index];
//     }

//     return node;
// }